### 기능 요구사항

- [x] controller를 @Controller를 활용하여 요청을 받도록 수정한다.
- [x] Jdbc Template을 이용하여 Connection을 직접 만들어주는 로직을 대체한다.
    - [x] boardDao에 적용한다.
    - [x] pieceDao에 적용한다.
- [x] Jdbc Template을 빈 주입을 받아서 사용한다.
    - [x] boardDao에 적용한다.
    - [x] pieceDao에 적용한다.
- [x] 체스방 만들기
    - [x] localhost:8080 요청 시 노출되는 페이지에 체스방을 만들 수 있는 버튼이 있다.
    - [x] 체스방 만들기 버튼을 누르고 체스방 제목과 비밀번호를 입력하면 새로운 체스판이 만들어진다.
    - [x] 체스방에는 고유식별값이 부여된다. (이 고유 식별값은 체스방 주소에서 사용 됨)
    - [x] 없는 체스방으로 요청 시 에러 페이지를 출력
- [x] 체스방 목록 조회하기
    - [x] localhost:8080 요청 시 체스방 목록을 조회할 수 있다
    - [x] 체스방 목록에는 체스방 제목과 체스방을 삭제할 수 있는 버튼이 표시된다.
- [x] 체스방 참여하기
    - [x] 체스방 목록에서 체스방 제목을 클릭하면 체스 게임을 이어서 진행할 수 있다.
- [x] 체스방 삭제하기
    - [x] 체스방 목록에서 체스방 삭제 버튼을 클릭하고 체스방 생성시 설정한 비밀번호를 입력하면 체스 게임을 삭제할 수 있다.
    - [x] 진행중인 체스방은 삭제할 수 없다.

---

### API 정리

- GET:`/` : 체스 방 리스트를 확인하고 새로운 체스 방을 만들 수 있는 페이지 출력.
- POST:`/chess/{boardId}` : 새로운 체스 게임을 생성한다.
- GET:`/chess/{boardId}` : 체스 게임을 할 수 있는 페이지 출력.
- DELETE:`/chess/{boardId}` : 체스 방을 제거한다.
- GET:`/chess/{boardId}/load` : 체스 기물 상태를 가져온다.
- GET:`/chess/{boardId}/restart` : 체스 게임을 재시작한다.
- GET:`/chess/{boardId}/status` : 체스 게임의 블랙, 화이트 팀의 점수를 반환한다.
- POST:`/chess/{boardId}/move` : 체스 게임에서 시작 위치, 도착 위치를 JSON으로 전송하면 이동한다. 정상적으로 이동 시 수정된 Board를 반환한다.

---

### 피드백, 수정사항 정리

- [x] 말을 이동한 뒤 말이 이동할 수 없는 경우 보드가 먹통이 되는 에러 수정해야 함
- [x] TODO, FIXME는 당장 필요가 없다면 PR에 있을 이유가 없음
- [x] `BoardDaoImpl`에서 `save`는 무조건 white 값을 넣고 있음
- [x] 테스트에서 BeforeEach로 매번 테이블을 만드는 쿼리가 실행되는데 이런 raw한 sql 쿼리문이 노출되지 않도록 구현할 수 있을까?
- [x] 불필요한 spark 의존성을 제거하자
- [x] Controller에서 발생하는 에러를 `@ExceptionHandler`, `@ControllerAdvice`를 이용하여 처리해보자.
    - `@ControllerAdvice`와 `@ExceptionHandler`를 이용하여 문제가 발생했을 때 에러를 처리할 수 있도록 함
    - 없는 체스방 URL로 요청 시 체스방 페이지가 아닌 잘못 접속했다는 페이지를 출력하도록함
    - 이동할 수 없는 이동을 할 경우 에러를 경고창으로 알려주기위해 예외 메시지를 400에러와 함께 전송하도록 함
- [x] Post 형식으로 데이터가 생성이 되었을 경우 status code(200)을 반환하는게 맞을까?
    - Post 형식으로 요청을 받아서 어떤 데이터가 생성된 경우 statue code(201)이 반환되어야 한다.
    - ResponseEntity에서는 ResponseEntity.created()를 사용하여 반환할 수 있다.
    - status code는 요청에 대한 처리 결과가 어떤지 알려주는 코드로 1~5xx 로 반환해준다.
    - 각 코드 간단 정리
        - 1xx : 요청이 성공하여 계속 진행될 수 있음을 나타냄
        - 2xx : 요청이 성공함
        - 3xx : 리다이렉션 상태를 나타내어 사용자에게 대안을 제시함
        - 4xx : 클라이언트의 문제로 에러가 발생함
        - 5xx : 서버의 문제로 에러가 발생함
- [x] ChessWebController의 `createRoom`의 newId는 board의 id 인지 room의 id 인지 명확하면 좋을 것 같다
    - board, room 테이블을 합치면서 room의 id를 사용하도록 수정했다.
- [x] 보통 자원을 지울때는 pk로 지우게 되는데 Room을 지울 때 pk가 아닌 boardId 값으로 지우게 된다. 혹시 같은 boardId를 여러 자원이 가진다면 모두 지우게 되는 것이 의도한 것일까?
    - board와 room 테이블을 합치면서 board_id가 아닌 roomId로 관리하도록 수정했다.
    - PieceDao의 `deleteByboardId()`는 roomId를 만족하는 모든 기물을 삭제하도록 `deleteAllByRoomId()`로 수정하였다.
    - RoomDao는 `delete()`를 사용하여 pk값인 id와 password값을 파라미터로 받아 삭제한다.
        - DB에 id와 password가 같은 데이터가 있는지 확인하는 방식(예를들면 `findByIdAndPassword()`)으로 패스워드 일치를 확인하고 `delete(id)`를 하는 식으로 할까 생각했었는데 글을 삭제하기 위해 무조건 비밀번호가 필요하다고 생각하여 `delete(id, password)`로 DAO 메서드를 만들었다.
- [x] 여러 DAO를 사용하여 자원을 처리하다가 에러가 발생해서 프로그램이 중단된다면 게임의 데이터는 어떤 상태로 유지 될까요?
    - 원자성과 트랜잭션을 키워드로 학습해보고 문제를 해결해볼까요?
    - `@Transactional`을 이용하여 여러 데이터를 처리하던 중 에러가 발생해도 원래 상태로 롤백할 수 있습니다. 
    - 내가 정한 모든 작업이 모두 성공하거나 모두 실패해야하는 성질을 원자성입니다. 
    - 또 `@Transactional`을 사용하면 서로 같은 자원을 수정하다가 한쪽이 롤백을 한다거나 할 때 발생하는 문제등을 해결할 수 있는데 이런 성질을 격리성이라고 합니다.
    - 여러 비즈니스 로직을 다루는 `Service`나 테스트에서 주로 사용한다고 합니다.
    - 저는 데이터를 읽기만 하는 경우 `@Transactional(readOnly = true)`으로 트랜잭션 어노테이션을 사용했고 나머지는 기본 설정으로 적용했습니다.
- [x] 게임을 하는 페이지에서 목록으로 이동하는 버튼이 있으면 어떨까?
    - 더 많은 가치를 만들어 내는 것이 없는지, 불편함은 없는지 등 조금 더 사용자 관점에서 생각해보도록 하자!

- 기존 `JdbcTemplate`없이 영속성 레이어를 구현할 때와 `JdbcTemplate`를 활용할 때의 차이점은 무엇일까?
    - 가장 체감되게 느낀 점 세 가지
        - Connection를 이용하여 열고 닫는 것들을 `JdbcTemplate`가 대신 관리해준다. 가독성을 해치는 try 문이 없어지고 에러가 나도 close 해준다.
        - PreparedStatement를 내가 할 필요없이 파라미터로 값을 주기만 하면 되어서 코드가 간단해지고 가독성이 높아졌다.
        - RowMapper를 따로 만들어주어야 하지만 코드 중간에 갑자기 ResultSet를 이용하는 것 보다 가독성이 좋아보였다. 특히 여러 값을 받아와야 한다면 반복문을 사용하지 않아도 되어서 보기
          편했다.
    - 이번 미션에서는 데이터 소스를 따로 만들지 않아 간단하게 사용할 수 있었지만 더 큰 프로젝트를 하거나 여러 DB에 접속해야 하는 상황에서도 `JdbcTemplate`를 활용하면 더 가독성이 좋은 코드로
      구현할 수 있을 것 같다.
    - 중간중간 `query`, `queryForObject`, `RowMapper` 사용에 익숙하지 않아서 기능 구현보다 에러 수정이 더 오래 걸린 것 같지만 공식 문서나 학습 테스트를 해보면서 해결해보니
      오히려 더 자신감이 생긴 것 같다.
- 스프링에서 의존성을 주입하는 방법은 생성자 주입, 필드 주입, 세터 주입이 있다. 왜 생성자 주입으로 구현했는가?
    - 처음에는 `JdbcTemplate`은 빈 주입을 하라는 요구사항을 만족하기 위해 `@Autowired`를 이요한 필드 주입 방식으로 구현했었다.
    - 그러나 `ChessService`를 테스트 할 때 DAO들에 가짜 객체를 주입해야하는데 그런 상황에서 `@AutoWired`가 적합하지 않았습니다.
    - 이러한 의존성 주입 방식을 찾다보니 생성자 주입, 필드 주입, 세터 주입이 있다고 했는데 미션의 요구사항과 가짜 객체를 적용하기에 생성자 주입이 가장 적합하다고 생각하여 적용했습니다.
    - 세터 주입도 가짜 객체를 주입할 수 있겠지만 불변성을 만족할 수 없다고 생각되어서 적용하지 않았습니다.
    - 이후 크루들과 이야기하면서 생성자 주입을 하면 직접 Null을 주입하지 않는 이상 NullPointerException이 발생하지 않고 스프링에서 생성자 주입 방식을 추천한다고 들었습니다.
- Optional을 사용하는 이유는 무엇일까요?

